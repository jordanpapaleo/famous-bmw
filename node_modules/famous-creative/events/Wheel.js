/**
 * Creates a global 'addWheelListener' method.
 *
 * @example
 *
 *     window.addWheelListener(elem, function (e) {
 *       e.preventDefault();
 *       console.log(e.deltaY);
 *     });
 *
 * @method  createAddWheelListener
 * @param   {Window}                window    Global window object.
 * @param   {Document}              document  Global document object.
 */
function createAddWheelListener(window, document) {
  let prefix = '';
  let _addEventListener;
  let support;

  // Detect event model
  if (window.addEventListener) {
    _addEventListener = 'addEventListener';
  } else {
    _addEventListener = 'attachEvent';
    prefix = 'on';
  }

  // Detect available wheel event
  // {wheel}           Supported by modern browsers
  // {mousewheel}      Supported by Webkit and IE
  // {DOMMouseScroll}  Support for older Firefox
  if ('onwheel' in document.createElement('div')) support = 'wheel';
  else if (document.onmousewheel !== undefined) support = 'mousewheel';
  else support = 'DOMMouseScroll';

  window.addWheelListener = function (elem, callback, useCapture) {
    _addWheelListener(elem, support, callback, useCapture);

    // Handle MozMousePixelScroll in older Firefox
    if (support === 'DOMMouseScroll') {
      _addWheelListener(elem, 'MozMousePixelScroll', callback, useCapture);
    }
  };

  function _addWheelListener(elem, eventName, callback, useCapture) {
    elem[ _addEventListener ](prefix + eventName, support === 'wheel' ? callback : function (originalEvent) {
      if (!originalEvent) originalEvent = window.event;

      // create a normalized event object
      let event = {
        // keep a ref to the original event object
        originalEvent: originalEvent,
        target: originalEvent.target || originalEvent.srcElement,
        type: 'wheel',
        deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
        deltaX: 0,
        deltaZ: 0,
        preventDefault: function () {
          if (originalEvent.preventDefault) originalEvent.preventDefault();
          else originalEvent.returnValue = false;
        }
      };

      // calculate deltaY (and deltaX) according to the event
      if (support === 'mousewheel') {
        let modifier = -(1 / 40);
        event.deltaY = modifier * originalEvent.wheelDelta;
        // Webkit also support wheelDeltaX
        if (originalEvent.wheelDeltaX) event.deltaX = modifier * originalEvent.wheelDeltaX;
      } else {
        event.deltaY = originalEvent.detail;
      }

      // it's time to fire the callback
      return callback(event);

    }, useCapture || false);
  }

}

// Only do this once
if (!window.addWheelListener) createAddWheelListener(window, document);

const defaultIncrement = Math.PI / 500;
const defaultRevolution = Math.PI * 2;
const degreesMultiplier = 180 / Math.PI;

class RotationEvent {
  /**
   * Return a new function closure that reports back the current rotation value.
   * @method  constructor
   * @constructor
   * @param   {String}     delta       Tells the Function closure to report back the deltaX or the deltaY.
   * @param   {Boolean}    useDegrees  If true use degrees instead of radians.
   * @return  {Function}   Function closure that is used to report back the current rotation value.
   */
  constructor(delta, useDegrees) {
    let dir = 'deltaX';
    if (delta === 'y') dir = 'deltaY';

    /**
     * Attaches a `wheel` event to `window`
     * @method  rotation
     * @param   {Object}    [options]            Optional options object.
     * @param   {Eleemnt}   options.eventTarget  The event target. Defaults to `window`.
     * @param   {Number}    options.friction     Set the friction of the rotation. Defaults to `4`.
     * @param   {Number}    options.increment    Set the amount to increment the rotation. Defaults to `Math.PI / 500`.
     * @param   {Number}    options.revolution   Set the value for 1 revolution. Defaults to `Math.PI * 2`.
     * @param   {Boolean}   options.natural      Set if the scrolling should be natural. Defaults to false.
     * @param   {Function}  callback             Function to call on mouse event.
     */
    return function rotation(options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      let eventTarget = options.eventTarget || window;
      let increment = options.increment || defaultIncrement;
      let revolution = options.revolution || defaultRevolution;
      let friction = options.friction || 4;
      let direction = (delta === 'y') ? 1 : -1;
      if (options.natural) direction *= -1;

      let angle = options.angle || 0;

      window.addWheelListener(eventTarget, (ev) => {
        ev.preventDefault();
        angle += (increment * ev[dir] / friction) * direction;
        if (angle >= revolution || angle <= -revolution) angle = 0;
        if (useDegrees) angle = angle * degreesMultiplier;
        callback(angle, dir);
      });
    };
  }
}

export default class Wheel {

  /**
   * Creates a new RotationEvent and returns a function that accepts an options argument and a callback.
   *
   * @example
   *
   *     // Set the Y rotation of a View
   *     let wheelX = Wheel.rotateX();
   *     wheelX((val) => {
   *       view.setRotationY(val);
   *     });
   *
   *     // Set the Y rotation of a View and optionally set a few properties
   *     let wheelX = Wheel.rotateX();
   *     wheelX({
   *       speed: 30,
   *       revolution: Math.PI * 4
   *     }, (val) => {
   *       this.setRotationY(val);
   *     });
   *
   * @method  rotateX
   * @param   {Boolean}   useDegrees  If true use degrees instead of radians.
   * @return  {Function}
   */
  static rotateX(useDegrees) {
    return new RotationEvent('x', useDegrees);
  }

  /**
   * Creates a new RotationEvent and returns a function that accepts an options argument and a callback.
   *
   * @example
   *
   *     // Set the X rotation of a View
   *     let wheelY = Wheel.rotateY();
   *     wheelX((val) => {
   *       view.setRotationY(val);
   *     });
   *
   *     // Set the X rotation of a View and optionally set a few properties
   *     let wheelY = Wheel.rotateY();
   *     wheelY({
   *       speed: 30,
   *       revolution: Math.PI * 4
   *     }, (val) => {
   *       this.setRotationX(val);
   *     });
   *
   * @method  rotateY
   * @param   {Boolean}   useDegrees  If true use degrees instead of radians.
   * @return  {Function}
   */
  static rotateY(useDegrees) {
    return new RotationEvent('y', useDegrees);
  }
}
